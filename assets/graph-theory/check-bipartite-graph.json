{"title": "Check whether a graph is bipartite", "summary": "This article describes what is bipartite graph and tells you how to determine if a graph is bipartite.", "author": "Junxiao Guo", "date": "2023-03-15", "tags": ["graph-theory"], "content": "---\ntitle: Check whether a graph is bipartite\nsummary: This article describes what is bipartite graph and tells you how to determine if a graph is bipartite.\nauthor: Junxiao Guo\ndate: 2023-03-15\ntags:\n    - graph-theory\n---\n\nA Bipartite Graph is a graph whose vertices can be divided into two independent sets, $U$ and $V$ such that every edge $(u, v)$ either connects a vertex from $U$ to $V$ or from $V$ to $U$. In other words, for every edge $(u, v)$, either $u$ belongs to $U$ and $v$ to $V$, or $u$ belongs to $V$ and $v$ to $U$,also, there is no edge that connects vertices of same set.\n\n![bipartite-graph](https://dsm01pap004files.storage.live.com/y4mtC_mu7NmRP7dJnv4hYJ0oAA9ruGnRIZiH4r5CHxEkYLUJNwUqbg8gLNTlcVDN2dkd8dnFBDNa2DpUYaGzr4pCPPBkP_MLwnvpROhyeTvIS1Wv5s3vAWPKdwoz-jHY8vDUBSdyMSsGX-xxoWjyUWXi1UnR85TTZpp-sU1LnE13B8OTBDvRUvbt5u9B3ggeYUR?width=320&height=158&cropmode=none)\n\nThe algorithm to check for the bipartiteness of a graph is like creating a fascinating canvas of colors. \n1. We have an array called color\\[\\] which stores 0 or 1 for every node. \n2. Then we call the function DFS to traverse the graph starting from any node. \n3. For each node visited, we assign !color\\[v\\] to color\\[u\\] if u has not been visited before. \n4. We then call DFS again to visit nodes connected to u. If at any point, the color of u is equal to the color of v, then the node is not bipartite. \n5. Finally, we modify the DFS function such that it returns a boolean value at the end.\n\n\nLet's define a graph as an 2D array, where graph\\[u\\] is an array of nodes that node u is adjacent to.\n\nBelow is the implementation of the above approach: \n\n\n```python\nfrom typing import List\ndef is_bipartite(graph: List[List[int]]) -> bool:\n        UNCOLORED,RED,BLUE = 0,1,2\n        n = len(graph)\n        status = [UNCOLORED] * n\n        valid = True\n\n        def dfs(node:int, color:int):\n            nonlocal valid\n            status[node] = color\n            neighbor_color = (RED if color==BLUE else BLUE)\n            for neighbor in graph[node]:\n                if status[neighbor] == UNCOLORED:\n                    dfs(neighbor,neighbor_color)\n                    if valid == False:\n                        return \n                elif status[neighbor] != neighbor_color:\n                    valid = False\n                    return\n\n        for i in range(n):\n            if status[i] == UNCOLORED:\n                dfs(i,RED)\n                if not valid:\n                    break\n\n        return valid\n\n```\n\n\n```python\ngraph = [[1,2,3],[0,2],[0,1,3],[0,2]]\nresult = is_bipartite(graph)\nprint(result)\n```\n\n    False\n\n\n\n```python\ngraph = [[1,3],[0,2],[1,3],[0,2]]\nresult = is_bipartite(graph)\nprint(result)\n```\n\n    True\n\n\n\n```python\n\n```\n"}